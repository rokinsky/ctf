#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from enum import Enum
from os import urandom
from pwn import *

import Crypto.Cipher.AES as AES
from Crypto.Random import get_random_bytes
import numpy as np
import math

A = b'a'
key = b'\x00' * 16
HASH = b'#'
SPACE = b' '
ZERO = b'\x00'

LOCALHOST = 'localhost'
HOST = 'h4x.0x04.net'
PORT = 13370
BLOCK_SIZE = AES.block_size
ENTER = b'Enter encrypted command.\n'

class Remote(pwnlib.tubes.remote.remote):
    def __init__(self, host, port):
        super().__init__(host, port)

    def sendx(self, msg):
        return super().sendline(msg.hex())

    def recvx(self, n):
        return super().recv(n)


class AESCipher:
    def __init__(self, remote):
        #self.key = md5(key.encode('utf8')).digest()
        self.r = remote

    def pad(self, data):
        l = len(data)
        n = math.ceil(l / AES.block_size) if l > 0 else 1
        return data.ljust(n * AES.block_size, b' ')

    def encrypt(self, msg):
        iv = bytearray(ZERO * AES.block_size)
        data = HASH

        for i in range(AES.block_size):
            for j in range(256):
                iv[i] = j
                self.r.sendx(self.pad(bytes(iv) + data))

            e = self.r.recvuntil(ENTER * 2).split(b'\n')
            x = list(filter(lambda z: z == ENTER[:-1], e))
            self.r.clean()
            iv[i] = len(x) - 1
            iv[i] ^= ord(HASH) ^ ord(SPACE)

        for i in range(len(msg)):
            iv[i] ^= ord(SPACE) ^ msg[i]

        return self.pad(iv + data)

    def decrypt(self, msg):
        basic_iv = bytearray(msg[:AES.block_size])
        iv = bytearray(basic_iv)
        msg = bytearray(msg[AES.block_size:])
        plaintext = b''

        for i in range(AES.block_size):
            for j in range(256):
                    iv[i] = j
                    self.r.sendx(self.pad(bytes(iv) + bytes(msg)))

            e = self.r.recvuntil(ENTER * 2).split(b'\n')
            x = list(filter(lambda z: z == ENTER[:-1], e))
            self.r.clean()
            iv[i] = len(x) - 1
            iv[i] ^= ord(HASH) ^ ord(SPACE)

        for i in range(AES.block_size):
            basic_iv[i] ^= ord(SPACE) ^ iv[i]

        plaintext += basic_iv

        # for i in range(AES.block_size):
        #     iv[i] ^= ord(SPACE) ^ msg[i]

        #raw = b64decode(msg)
        #self.cipher = AES.new(self.key, AES.MODE_CBC, raw[:AES.block_size])
        #return unpad(self.cipher.decrypt(raw[AES.block_size:]), AES.block_size)


        # self.r.sendx(self.pad(bytes(iv) + bytes(msg)))
        # self.r.sendx(self.pad(bytes(iv) + bytes(msg)))
        # self.r.sendx(self.pad(bytes(iv) + bytes(msg)))
        # self.r.sendx(self.pad(bytes(iv) + bytes(msg)))


        info(f'msg before: {bytes(msg)}')

        #iv[i] ^= basic_iv[i]
        #iv[i] ^= ord(HASH)
        #msg[0] ^= iv[0]
        #msg[0] ^= ord(b'B')




        info(f'plaintext: {bytes(plaintext)}')

        info(f'msg after: {bytes(msg)}')

        return msg


class Exploit:
    def __init__(self, host, port):
        self.r = Remote(host, port)
        self.aes = AESCipher(self.r)

    def run(self):
        #iv = get_random_bytes(BLOCK_SIZE)
        self.r.recvuntil(ENTER)
        self.r.sendx(self.aes.encrypt(b'cat flag.txt'))
        raw = bytes.fromhex(self.r.recvline().decode())
        self.r.clean()
        info(f'encrypted flag: {raw}')
        flag = self.aes.decrypt(raw)


        #cipher = AES.new(mode=AES.MODE_CBC, key=key, iv=iv)
        #msg = iv + cipher.encrypt(b'\x01' * 15 + b'\x01')
        #msg += b'cat    flag.txt flag.txt flag.txt flag.txt'
        #msg = b'dupa'

        #self.r.send(msg.hex())
        #self.r.close()

        self.r.interactive()


def main():
    Exploit(LOCALHOST, PORT).run()


if __name__ == '__main__':
    main()
