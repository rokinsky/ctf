#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from enum import Enum
from os import urandom
from pwn import *

import Crypto.Cipher.AES as AES
from Crypto.Random import get_random_bytes
import numpy as np
import math

A = b'a'
key = b'\x00' * 16
HASH = b'#'

LOCALHOST = 'localhost'
HOST = 'h4x.0x04.net'
PORT = 13370
BLOCK_SIZE = AES.block_size
ENTER = b'Enter encrypted command.\n'

class Remote(pwnlib.tubes.remote.remote):
    def __init__(self, host, port):
        super().__init__(host, port)

    def sendx(self, msg):
        return super().sendline(msg.hex())

    def recvx(self, n):
        return super().recv(n)


class AESCipher:
    def __init__(self, remote):
        #self.key = md5(key.encode('utf8')).digest()
        self.r = remote

    def pad(self, data):
        l = len(data)
        n = math.ceil(l / AES.block_size) if l > 0 else 1
        return data.ljust(n * AES.block_size, b'#')

    def encrypt(self, data):
        iv = bytearray(AES.block_size * b'\x00')
        data = 0 * b' ' + b'#'
        for i in range(256):
            iv[0] = i
            self.r.sendx(self.pad(bytes(iv) + data))

        recv = self.r.recvuntil(ENTER * 2)
        #print(recv)

        recv = recv.split(b'\n')
        x = list(filter(lambda y: y == ENTER[:-1], recv))
        self.r.clean()
        iv[0] = (len(x) - 2) ^ ord(b'#') ^ ord(b' ')
        #iv[0] = (len(x) - 2)
        print('first', len(x) - 2)

        #iv[0] -= ord(b'#') - ord(b' ')

        #self.r.sendx(self.pad(iv + 1 * b'#' + b' '))
        #self.r.sendx(self.pad(iv + 1 * b' ' + b' '))
        self.r.sendx(self.pad(iv + 1 * b'#' + b'#'))
        #self.r.sendx(self.pad(iv + 1 * b'#' + b' '))

        # self.r.sendx(self.pad(iv + 1 * b' ' + b'#'))
        # self.r.sendx(self.pad(iv + 1 * b' ' + b'#'))
        # self.r.sendx(self.pad(iv + 1 * b' ' + b'#'))
        # self.r.sendx(self.pad(iv + 1 * b' ' + b'#'))
        # self.r.sendx(self.pad(iv + 1 * b' ' + b'#'))

        #self.r.sendx(self.pad(iv + data))
        ivc = iv
        #ivc[0] = iv[0] - 3

        # self.r.sendx(self.pad(ivc + 1 * b' ' + b'#'))
        # self.r.sendx(self.pad(bytes([iv[0] - 3]) + 15 * b'\x00' + 1 * b'#'))
        # self.r.sendx(self.pad(bytes([iv[0] - 2]) + 15 * b'\x00' + 1 * b'#'))
        # self.r.sendx(self.pad(bytes([iv[0] - 1]) + 15 * b'\x00' + 1 * b'#'))

        # self.r.sendx(AES.block_size * b'\x00' + self.pad(bytes(iv[0])))
        #data = self.pad(bytes(iv[0]) + b'#')
        #iv[0] -= ord(b'#') - ord(b' ')

        print('diff', ord(b'#') - ord(b' '))
        print('iv[0]', iv[0])
        data = 1 * b'#' + b'#'
        for i in range(256):
             iv[1] = i
             self.r.sendx(self.pad(bytes(iv) + data))
        
        x = list(filter(lambda y: y == ENTER[:-1], self.r.recvuntil(ENTER * 2).split(b'\n')))
        self.r.clean()

        print('second', len(x))
        iv[1] = len(x) - 2
        self.r.sendx(self.pad(iv + 1 * b'#' + b'#'))
        self.r.sendx(self.pad(iv + 1 * b'#' + b'#'))
        self.r.sendx(self.pad(iv + 1 * b'#' + b'#'))
        self.r.sendx(self.pad(iv + 1 * b'#' + b'#'))
        self.r.sendx(self.pad(iv + 1 * b'#' + b'#'))
        self.r.sendx(self.pad(iv + 1 * b'#' + b'#'))




        #self.r.clean()

        # iv[1] = len(x) - 2
        # self.r.sendx(iv + data)




    def decrypt(self, data):
        raw = b64decode(data)
        self.cipher = AES.new(self.key, AES.MODE_CBC, raw[:AES.block_size])
        return unpad(self.cipher.decrypt(raw[AES.block_size:]), AES.block_size)


class Exploit:
    def __init__(self, host, port):
        self.r = Remote(host, port)
        self.aes = AESCipher(self.r)

    def run(self):
        #iv = get_random_bytes(BLOCK_SIZE)
        iv = b'\x00' * 16

        print(len(self.aes.pad(HASH * 17)))
        self.aes.encrypt(HASH)
        #cipher = AES.new(mode=AES.MODE_CBC, key=key, iv=iv)
        #msg = iv + cipher.encrypt(b'\x01' * 15 + b'\x01')
        #msg += b'cat    flag.txt flag.txt flag.txt flag.txt'
        msg = b'ls   sl'
        msg = b'\x6c\x73\x20\x20\x20\x73\x6c'
        #msg = b'dupa'

        #self.r.send(msg.hex())
        #self.r.close()

        self.r.interactive()


def main():
    Exploit(LOCALHOST, PORT).run()


if __name__ == '__main__':
    main()
