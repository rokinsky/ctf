#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from enum import Enum
from pwn import *

import Crypto.Cipher.AES as AES
import math
import numpy as np

HASH = b'#'
SPACE = b' '

COMMAND = b'cat flag.txt'
ENTER = b'Enter encrypted command.\n'

HOST = 'h4x.0x04.net'
LOCALHOST = 'localhost'
PORT = 13370


def pad(data):
    l = len(data)
    n = math.ceil(l / AES.block_size) if l > 0 else 1
    return data.ljust(n * AES.block_size, SPACE)


def unpad(data):
    return data.rstrip(SPACE)


class Remote(pwnlib.tubes.remote.remote):
    def __init__(self, host, port):
        super().__init__(host, port)

    def sendx(self, msg):
        return super().sendline(pad(msg).hex())

    def recvx(self):
        return bytes.fromhex(super().recvline().decode())


class AESCipher:
    def __init__(self, remote):
        self.r = remote

    def h4x(self, iv, data):
        for i in range(AES.block_size):
            for j in range(256):
                    iv[i] = j
                    self.r.sendx(bytes(iv) + bytes(data))

            e = self.r.recvuntil(ENTER * 2, timeout=1).split(b'\n')
            x = list(filter(lambda z: z == ENTER[:-1], e))

            self.r.clean()
            iv[i] = max(len(x) - 1, 0)
            iv[i] ^= ord(HASH) ^ ord(SPACE)

        return iv

    def encrypt(self, msg):
        self.r.recvuntil(ENTER, timeout=1)

        msg = pad(msg)
        ciphertext = b''

        # TODO support for larger messages
        assert len(msg) <= AES.block_size

        iv = bytearray(AES.block_size)
        data = msg

        iv = self.h4x(iv, data)

        for i in range(AES.block_size):
            iv[i] ^= ord(SPACE) ^ data[i]

        return iv + data

    def decrypt(self, msg):
        self.r.recvuntil(ENTER, timeout=1)

        plaintext = b''

        assert len(msg) % AES.block_size == 0

        n = len(msg) // AES.block_size
        for k in range(1, n):
            basic_iv = bytearray(msg[AES.block_size * (k - 1):AES.block_size * k])
            iv = bytearray(basic_iv)
            data = bytearray(msg[AES.block_size * k:AES.block_size * (k + 1)])

            iv = self.h4x(iv, data + SPACE)

            for i in range(AES.block_size):
                basic_iv[i] ^= ord(SPACE) ^ iv[i]

            plaintext += basic_iv

        return plaintext


class Exploit:
    def __init__(self, host, port):
        self.r = Remote(host, port)
        self.aes = AESCipher(self.r)

    def run(self, command):
        self.r.sendx(self.aes.encrypt(command))
        info(unpad(self.aes.decrypt(self.r.recvx())))

    def __del__(self):
        self.r.close()


if __name__ == '__main__':
    Exploit(LOCALHOST, PORT).run(COMMAND)
